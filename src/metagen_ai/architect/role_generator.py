# src/metagen_ai/architect/role_generator.py
from __future__ import annotations
from typing import List, Dict, Any, Optional
import json, re
from dataclasses import dataclass
from metagen_ai.roles.schema import RoleProfile

_JSON_BLOCK = re.compile(r"```json\s*(.*?)\s*```", re.S|re.I)

_BRACKET_Q = re.compile(r"\{task\[['\"]?question['\"]?\]\}")
_BRACKET_A = re.compile(r"\{task\[['\"]?answer['\"]?\]\}")
_BRACKET_QUERY = re.compile(r"\{task\[['\"]?query['\"]?\]\}")

@dataclass
class GenCfg:
    num_new: int = 3
    max_name_len: int = 32
    diversity_weight: float = 0.3
    max_template_len: int = 1600

def _dedup_by_semantics(cands: List[RoleProfile]) -> List[RoleProfile]:
    # 轻量去重：同名/描述相似（粗暴）直接过滤
    seen = set()
    out = []
    for rp in cands:
        key = (rp.name.strip().lower(), rp.description.strip().lower())
        if key in seen: 
            continue
        seen.add(key)
        out.append(rp)
    return out

def _norm_placeholders(s: str) -> str:
    s = _BRACKET_Q.sub("{question}", s)
    s = _BRACKET_A.sub("{answer}", s)
    s = _BRACKET_QUERY.sub("{query}", s)
    return s

def _coerce_role(d: Dict[str, Any]) -> Optional[RoleProfile]:
    try:
        name = str(d["name"]).strip()[:32]
        desc = str(d.get("description", "")).strip()
        sys = _norm_placeholders(str(d.get("system_template", "")).strip())
        usr = _norm_placeholders(str(d.get("user_template", "")).strip())
        if not name or not sys or not usr:
            return None
        bad = ["{{tool:", "{% exec", "```python", "os.system", "subprocess"]
        if any(b in (sys.lower()+usr.lower()) for b in bad):
            return None
        return RoleProfile(
            name=name,
            description=desc or f"Autogenerated role {name}",
            system_template=sys[:1600],
            user_template=usr[:1600],
            local_handler=None,
            temperature=None,
        )
    except Exception:
        return None

def _parse_roles(text: str) -> List[RoleProfile]:
    # 允许裸 JSON 或 ```json fenced block
    m = _JSON_BLOCK.search(text) or None
    js = m.group(1) if m else text
    data = None
    try:
        data = json.loads(js)
    except Exception:
        return []
    if isinstance(data, dict):
        data = [data]
    out = []
    if isinstance(data, list):
        for item in data:
            rp = _coerce_role(item or {})
            if rp: out.append(rp)
    return out

def generate_roles(task: Dict[str, Any], cfg: Dict[str, Any], llm) -> List[RoleProfile]:
    """
    用 Architect LLM 生成若干新角色；返回 RoleProfile 列表（已做安全校验与去重）。
    """
    rcfg = (cfg.get("role_gen") or {})
    gcfg = GenCfg(
        num_new=int(rcfg.get("num_new", 3)),
        diversity_weight=float(rcfg.get("diversity_weight", 0.3)),
    )
    # 架构提示：要求输出 JSON 数组；每个元素包含 name/description/system_template/user_template
    sys = (
        "You are an architect that designs specialized agent roles for a multi-agent LLM system.\n"
        "Return ONLY a JSON array. Each element MUST be an object with keys:\n"
        "name, description, system_template, user_template.\n"
        "No extra commentary."
    )
    usr = (
        f"Task:\n{task}\n\n"
        f"Design {gcfg.num_new} diverse roles that collaborate to solve the task type.\n"
        "Constraints:\n"
        "- Use ONLY these placeholders: {question}, {answer}, {query}, {inputs}, {prev_summary}.\n"
        "- Do NOT use dict indexing like {task['question']} or Jinja syntax.\n"
        "- Make system_template concise with clear input/output contract.\n"
        "- user_template should reference the allowed placeholders if needed.\n"
        "- Avoid any external tools or code execution; pure language reasoning.\n"
        "Return JSON ONLY."
    )
    messages = [{"role":"system","content":sys},{"role":"user","content":usr}]
    resp = llm.chat(messages, temperature=0.2, max_tokens=800)
    roles = _parse_roles(resp["text"])
    roles = _dedup_by_semantics(roles)
    # 限长兜底
    for r in roles:
        r.system_template = r.system_template[:gcfg.max_template_len]
        r.user_template = r.user_template[:gcfg.max_template_len]
    return roles
